{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/","matchPath":"/*","webpackCompilationHash":"30a1337d460fe9ac325f","result":{"data":{"deck":{"id":"2350c446-1a31-51c0-ba75-976f78308e86","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = github;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"div\", null, mdx(\"img\", {\n    style: {\n      width: \"600px\",\n      borderRadius: \"250px\"\n    },\n    src: glowingLogo\n  })), mdx(\"h1\", null, \"Back to the Future\"), mdx(\"hr\", null), mdx(\"h2\", null, \"2008 meets 2022\"), mdx(\"div\", {\n    style: {\n      display: \"grid\",\n      gap: \"1rem\",\n      gridTemplateColumns: \"auto auto\",\n      marginBottom: \"40px\"\n    }\n  }, mdx(\"div\", {\n    style: {\n      textAlign: \"right\"\n    }\n  }, \"Old\"), mdx(\"div\", null, mdx(\"span\", null, \"tech\"), \"niques\"), mdx(\"div\", null, \"New\"), mdx(\"div\", null, mdx(\"span\", null, \"tech\"), \"ologies\")), mdx(\"ul\", {\n    style: {\n      fontSize: \"32px\"\n    }\n  }, mdx(\"li\", null, \"No more \", mdx(\"code\", null, \"event.prefentDefault()\"), \" on form submissions.\"), mdx(\"li\", null, \"No more spinnerama as you make 5 separate client side requests for data.\"), mdx(\"li\", null, \"Heck, no more clientside code if you want.\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Routing\"), mdx(\"ul\", {\n    style: {\n      fontSize: \"32px\"\n    }\n  }, mdx(\"li\", null, \"File based routing\"), mdx(\"li\", null, \"Nested routes (w/ nested layouts)\")), mdx(\"div\", {\n    style: {\n      display: \"flex\",\n      gap: \"40px\",\n      padding: \"40px\",\n      marginTop: \"40px\",\n      fontSize: \"24px\"\n    }\n  }, mdx(\"table\", null, mdx(\"thead\", null, mdx(\"tr\", null, mdx(\"th\", null, \"File Path\"), mdx(\"th\", null, \"Url Path\"), mdx(\"th\", null))), mdx(\"tbody\", null, mdx(\"tr\", null, mdx(\"td\", null, \"/routes/bookmarks/index.tsx\"), mdx(\"td\", null, \"/bookmarks\"), mdx(\"td\", null, \"The list view.\")), mdx(\"tr\", null, mdx(\"td\", null, \"/routes/bookmarks/new.tsx\"), mdx(\"td\", null, \"/bookmarks/new\"), mdx(\"td\", null, \"The new form\")), mdx(\"tr\", null, mdx(\"td\", null, \"/routes/bookmarks/$bookmarkId.tsx\"), mdx(\"td\", null, \"/bookmarks/:id\"), mdx(\"td\", null, \"The details view\", mdx(\"br\", null), \"Dynamic segment for \", mdx(\"code\", null, \"bookmarkId\"))), mdx(\"tr\", null, mdx(\"td\", null, \"/routes/bookmarks/$bookmarkId.edit.tsx\"), mdx(\"td\", null, \"/bookmarks/:id/edit\"), mdx(\"td\", null, \"The edit form\", mdx(\"br\", null), \"Nested url without actually nesting the file\")), mdx(\"tr\", null, mdx(\"td\", null, \"/routes/bookmarks.tsx\"), mdx(\"td\", null, \"/bookmarks/*\"), mdx(\"td\", null, \"A \\\"Layout\\\" route. \", mdx(\"br\", null), \"Wraps all bookmarks child routes.\")))), mdx(\"div\", null, mdx(\"img\", {\n    style: {\n      width: \"500px\"\n    },\n    src: bookmarksRoutesImage\n  }))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [vsDark, github],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Basic List view\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Classic react'\",\n    \"subtitle\": \"'Classic\",\n    \"react'\": true\n  }), \"export default BookmarksView = () => {\\n  const bookmarks = [];\\n\\n  return (\\n    <div>\\n      <h2>Bookmarks</h2>\\xDF\\n      <ul>\\n        {bookmarks.map((bookmark) => (\\n          <li key={bookmark.id}>\\n            <a href={bookmark.url}>{bookmark.title}</a>\\n          </li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Remix'\",\n    \"subtitle\": \"'Remix'\"\n  }), \"export default BookmarksView = () => {\\n  const bookmarks = [];\\n\\n  return (\\n    <div>\\n      <h2>Bookmarks</h2>\\n      <ul>\\n        {bookmarks.map((bookmark) => (\\n          <li key={bookmark.id}>\\n            <a href={bookmark.url}>{bookmark.title}</a>\\n          </li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n};\\n\"))), mdx(Step, {\n    title: \"List View w/ Data Fetching\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Classic react'\",\n    \"subtitle\": \"'Classic\",\n    \"react'\": true\n  }), \"export default BookmarksView = () => {\\n  const [bookmarks, setBookmarks] = useState([]);\\n  useEffect(() => {\\n    fetch(\\\"/api/bookmarks\\\")\\n      .then((res) => res.json())\\n      .then((data) => setBookmarks(data));\\n  }, []);\\n\\n  return (\\n    <div>\\n      <h2>Bookmarks</h2>\\n      <ul>\\n        {bookmarks.map((bookmark) => (\\n          <li key={bookmark.id}>\\n            <a href={bookmark.url}>{bookmark.title}</a>\\n          </li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Remix'\",\n    \"subtitle\": \"'Remix'\"\n  }), \"// This executes ONLY serverside\\nexport const loader = () => {\\n  return fetch(\\\"/api/bookmarks\\\");\\n};\\n\\nexport default BookmarksView = () => {\\n  const bookmarks = useLoaderData();\\n\\n  return (\\n    <div>\\n      <h2>Bookmarks</h2>\\n      <ul>\\n        {bookmarks.map((bookmark) => (\\n          <li key={bookmark.id}>\\n            <a href={bookmark.url}>{bookmark.title}</a>\\n          </li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n};\\n\")))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [vsDark, github],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Happy Path Data Fetching\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Classic react'\",\n    \"subtitle\": \"'Classic\",\n    \"react'\": true\n  }), \"export default BookmarksView = () => {\\n  const [bookmarks, setBookmarks] = useState([]);\\n  useEffect(() => {\\n    fetch(\\\"/api/bookmarks\\\")\\n      .then((res) => res.json())\\n      .then((data) => setBookmarks(data));\\n  }, []);\\n\\n  return (\\n    <div>\\n      <h2>Bookmarks</h2>\\n      <ul>\\n        {bookmarks.map((bookmark) => (\\n          <li key={bookmark.id}>\\n            <a href={bookmark.url}>{bookmark.title}</a>\\n          </li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Remix'\",\n    \"subtitle\": \"'Remix'\"\n  }), \"export const loader = () => {\\n  return fetch(\\\"/api/bookmarks\\\");\\n};\\n\\nexport default BookmarksView = () => {\\n  const bookmarks = useLoaderData();\\n\\n  return (\\n    <div>\\n      <h2>Bookmarks</h2>\\n      <ul>\\n        {bookmarks.map((bookmark) => (\\n          <li key={bookmark.id}>\\n            <a href={bookmark.url}>{bookmark.title}</a>\\n          </li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n};\\n\"))), mdx(Step, {\n    title: \"Data Fetching w/ Loading State and Errors\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Classic react'\",\n    \"subtitle\": \"'Classic\",\n    \"react'\": true\n  }), \"//\\n// Add state to track isLoading and Errors\\nexport default BookmarksView = () => {\\n  const [bookmarks, setBookmarks] = useState([]);\\n  const [isLoading, setIsLoading] = useState(false);\\n  const [error, setError] = useState(\\\"\\\");\\n\\n  useEffect(() => {\\n    setIsLoading(true);\\n    fetch(\\\"/api/bookmarks\\\")\\n      .then((res) => res.json())\\n      .then((data) => setBookmarks(data))\\n      .catch((err) => setError(err.message))\\n      .finally(() => setIsLoading(false));\\n  }, []);\\n\\n  return (\\n    <div>\\n      <h2>Bookmarks</h2>\\n      {isLoading && <div>Loading...</div>}\\n      {error && !isLoading && <div>Error: {error}</div>}\\n      {!error && !isLoading && (\\n        <ul>\\n          {bookmarks.map((bookmark) => (\\n            <li key={bookmark.id}>\\n              <a href={bookmark.url}>{bookmark.title}</a>\\n            </li>\\n          ))}\\n        </ul>\\n      )}\\n    </div>\\n  );\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Remix'\",\n    \"subtitle\": \"'Remix'\"\n  }), \"// We don't have to deal with a loading state\\nexport const loader = () => {\\n  return fetch(\\\"/api/bookmarks\\\");\\n};\\n\\nexport default BookmarksView = () => {\\n  const bookmarks = useLoaderData();\\n\\n  return (\\n    <div>\\n      <h2>Bookmarks</h2>\\n      <ul>\\n        {bookmarks.map((bookmark) => (\\n          <li key={bookmark.id}>\\n            <a href={bookmark.url}>{bookmark.title}</a>\\n          </li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n};\\n\\nexport const ErrorBoundary = ({ error }) => (\\n  <div>Error:{error.message}</div>\\n);\\n\")))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [vsDark, github],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Basic Edit Form\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Classic React'\",\n    \"subtitle\": \"'Classic\",\n    \"React'\": true\n  }), \"export default function BookmarkForm() {\\n  return (\\n    <form>\\n      <label>\\n        Title\\n        <input name=\\\"title\\\" />\\n      </label>\\n      <label>\\n        URL\\n        <input name=\\\"url\\\" />\\n      </label>\\n      <label>\\n        Description\\n        <textarea name=\\\"description\\\" />\\n      </label>\\n      <button type=\\\"submit\\\">Save</button>\\n    </form>\\n  );\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Remix'\",\n    \"subtitle\": \"'Remix'\"\n  }), \"export default function BookmarkForm() {\\n  return (\\n    <form>\\n      <label>\\n        Title\\n        <input name=\\\"title\\\" />\\n      </label>\\n      <label>\\n        URL\\n        <input name=\\\"url\\\" />\\n      </label>\\n      <label>\\n        Description\\n        <textarea name=\\\"description\\\" />\\n      </label>\\n      <button type=\\\"submit\\\">Save</button>\\n    </form>\\n  );\\n}\\n\"))), mdx(Step, {\n    title: \"Fetching data (initial form values)\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"subtitle=\\\"Classic React\\\"\",\n    \"subtitle\": \"\\\"Classic\",\n    \"React\\\"\": true\n  }), \"export default function BookmarkForm() {\\n  let { bookmarkId } = useParams();\\n  let [formValues, setFormValues] = useState(null);\\n\\n  // Fetch the form values for the item we are editing\\n  useEffect(() => {\\n    if (bookmarkId) {\\n      bookmarksApi\\n        .getById(bookmarkId)\\n        .then((data) => setFormValues(data));\\n        .catch(err => {\\n          // TODO: Gracefully handle error\\n          console.error(\\\"Fetch failed\\\", err)\\n        })\\n    }\\n  }, [bookmarkId]);\\n\\n  // To avoid a blip, show a spinner until initial values are loaded\\n  // Until we gracefully handle errors, the user will see an infiinite spinner\\n  if (!formValues) return <Loading />;\\n\\n  return (\\n    <form>\\n      <label>\\n        Title\\n        <input name=\\\"title\\\" />\\n      </label>\\n      <label>\\n        URL\\n        <input name=\\\"url\\\" />\\n      </label>\\n      <label>\\n        Description\\n        <textarea name=\\\"description\\\" />\\n      </label>\\n      <button type=\\\"submit\\\">Save</button>\\n    </form>\\n  );\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Remix'\",\n    \"subtitle\": \"'Remix'\"\n  }), \"// This executes serverside\\nexport const loader = ({ params }) => {\\n  let bookmark = bookmarkService.get(params.bookmarkId);\\n  return { bookmark };\\n};\\n\\n// This executes serverside for SSR and clientside once hydrated\\n// No need to handle a loading or error state.\\n// This component will only render after/if the loader succeeds\\nexport default function BookmarkForm() {\\n  let { bookmark } = useLoaderData();\\n  return (\\n    <form>\\n      <label>\\n        Title\\n        <input name=\\\"title\\\" />\\n      </label>\\n      <label>\\n        URL\\n        <input name=\\\"url\\\" />\\n      </label>\\n      <label>\\n        Description\\n        <textarea name=\\\"description\\\" />\\n      </label>\\n      <button type=\\\"submit\\\">Save</button>\\n    </form>\\n  );\\n}\\n\")))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [vsDark, github],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Form initialized with fetched data\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"subtitle=\\\"Classic React\\\"\",\n    \"subtitle\": \"\\\"Classic\",\n    \"React\\\"\": true\n  }), \"//\\n//\\nexport default function BookmarkForm() {\\n  let { bookmarkId } = useParams();\\n  // Track form values with component state\\n  let [formValues, setFormValues] = useState(null);\\n\\n  // Fetch the form values for the item we are editing\\n  useEffect(() => {\\n    if (bookmarkId) {\\n      bookmarksApi\\n        .getById(bookmarkId)\\n        .then((data) => setFormValues(data));\\n    }\\n  }, [bookmarkId]);\\n\\n  // To avoid a blip, show a spinner until initial values are loaded\\n  if (!formValues) return <Loading />;\\n\\n  return (\\n    <form>\\n      <label>\\n        Title\\n        <input name=\\\"title\\\" value={formValues.title} />\\n      </label>\\n      <label>\\n        URL\\n        <input name=\\\"url\\\" value={formValues.url} />\\n      </label>\\n      <label>\\n        Description\\n        <textarea\\n          name=\\\"description\\\"\\n          value={formValues.description}\\n        />\\n      </label>\\n      <button type=\\\"submit\\\">Save</button>\\n    </form>\\n  );\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Remix'\",\n    \"subtitle\": \"'Remix'\"\n  }), \"//\\nexport const loader = ({ params }) => {\\n  let bookmark = bookmarkService.get(params.bookmarkId);\\n  return { bookmark };\\n};\\n\\nexport default function BookmarkForm() {\\n  let { bookmark } = useLoaderData();\\n\\n  return (\\n    <form>\\n      <label>\\n        Title\\n        <input name=\\\"title\\\" defaultValue={bookmark.title} />\\n      </label>\\n      <label>\\n        URL\\n        <input name=\\\"url\\\" defaultValue={bookmark.url} />\\n      </label>\\n      <label>\\n        Description\\n        <textarea\\n          name=\\\"description\\\"\\n          defaultValue={bookmark.description}\\n        />\\n      </label>\\n      <button type=\\\"submit\\\">Save</button>\\n    </form>\\n  );\\n}\\n\"))), mdx(Step, {\n    title: \"Form submission\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"subtitle=\\\"Classic React\\\"\",\n    \"subtitle\": \"\\\"Classic\",\n    \"React\\\"\": true\n  }), \"export default function BookmarkForm() {\\n  let { bookmarkId } = useParams();\\n  let [formValues, setFormValues] = useState(null);\\n\\n  // Fetch the form values for the item we are editing\\n  useEffect(() => {\\n    if (bookmarkId) {\\n      bookmarksApi\\n        .getById(bookmarkId)\\n        .then((data) => setFormValues(data));\\n    }\\n  }, [bookmarkId]);\\n\\n  // To avoid a blip, show a spinner until initial values are loaded\\n  if (!formValues) return <Loading />;\\n\\n  //\\n\\n  const updateFormValue = (key, value) => {\\n    setFormValues({ ...formValues, [key]: value });\\n  };\\n\\n  // This is clientside code\\n  const handleSubmit = async (e) => {\\n    // make sure the page doesn't refresh\\n    e.preventDefault();\\n    let result = await bookmarksApi.save(formValues);\\n    // Navigate to the display/details view of the saved item\\n    navigate(`/bookmarks/${result.id}`);\\n  };\\n\\n  return (\\n    <form onSubmit={handleSubmit}>\\n      <label>\\n        Title\\n        <input\\n          name=\\\"title\\\"\\n          value={formValues.title}\\n          onChange={(e) =>\\n            updateFormValue(\\\"title\\\", e.currentTarget.value)\\n          }\\n        />\\n      </label>\\n      <label>\\n        URL\\n        <input\\n          name=\\\"url\\\"\\n          value={formValues.url}\\n          onChange={(e) =>\\n            updateFormValue(\\\"url\\\", e.currentTarget.value)\\n          }\\n        />\\n      </label>\\n      <label>\\n        Description\\n        <textarea\\n          name=\\\"description\\\"\\n          value={formValues.description}\\n          onChange={(e) =>\\n            updateFormValue(\\n              \\\"description\\\",\\n              e.currentTarget.value\\n            )\\n          }\\n        />\\n      </label>\\n      <button type=\\\"submit\\\">Save</button>\\n    </form>\\n  );\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Remix'\",\n    \"subtitle\": \"'Remix'\"\n  }), \"export const loader = ({ params }) => {\\n  let bookmark = bookmarkService.get(params.bookmarkId);\\n  return { bookmark };\\n};\\n\\n// This is serverside code\\nexport const action = async ({ request }) => {\\n  let formData = await request.formData();\\n  let result = await bookmarkService.save(formData);\\n  // Navigate to the display/details view of the saved item\\n  return redirect(`/bookmarks/${result.id}`);\\n};\\n\\nexport default function BookmarkForm() {\\n  let { bookmark } = useLoaderData();\\n\\n  return (\\n    <form method=\\\"post\\\">\\n      <label>\\n        Title\\n        <input name=\\\"title\\\" defaultValue={bookmark.title} />\\n      </label>\\n      <label>\\n        URL\\n        <input name=\\\"url\\\" defaultValue={bookmark.url} />\\n      </label>\\n      <label>\\n        Description\\n        <textarea\\n          name=\\\"description\\\"\\n          defaultValue={bookmark.description}\\n        />\\n      </label>\\n      <button type=\\\"submit\\\">Save</button>\\n    </form>\\n  );\\n}\\n\")))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [vsDark, github],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Full form code\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"subtitle=\\\"Classic React\\\"\",\n    \"subtitle\": \"\\\"Classic\",\n    \"React\\\"\": true\n  }), \"//\\n//\\nexport default function BookmarkForm() {\\n  let [formValues, setFormValues] = useState(null);\\n  let { bookmarkId } = useParams();\\n\\n  // Fetch the form values for the item we are editing\\n  useEffect(() => {\\n    if (bookmarkId) {\\n      bookmarksApi\\n        .getById(bookmarkId)\\n        .then((data) => setFormValues(data));\\n    }\\n  }, [bookmarkId]);\\n\\n  // To avoid a blip, show a spinner until initial values are loaded\\n  if (!formValues) return <Loading />;\\n\\n  const updateFormValue = (key, value) => {\\n    setFormValues({ ...formValues, [key]: value });\\n  };\\n\\n  // This is clientside code\\n  const handleSubmit = async (e) => {\\n    // make sure the page doesn't refresh\\n    e.preventDefault();\\n    let result = await bookmarksApi.save(formValues);\\n    // Navigate to the display/details view of the saved item\\n    navigate(`/bookmarks/${result.id}`);\\n  };\\n\\n  return (\\n    <form onSubmit={handleSubmit}>\\n      <label>\\n        Title\\n        <input\\n          name=\\\"title\\\"\\n          value={formValues.title}\\n          onChange={(e) =>\\n            updateFormValue(\\\"title\\\", e.currentTarget.value)\\n          }\\n        />\\n      </label>\\n      <label>\\n        URL\\n        <input\\n          name=\\\"url\\\"\\n          value={formValues.url}\\n          onChange={(e) =>\\n            updateFormValue(\\\"url\\\", e.currentTarget.value)\\n          }\\n        />\\n      </label>\\n      <label>\\n        Description\\n        <textarea\\n          name=\\\"description\\\"\\n          value={formValues.description}\\n          onChange={(e) =>\\n            updateFormValue(\\n              \\\"description\\\",\\n              e.currentTarget.value\\n            )\\n          }\\n        />\\n      </label>\\n      <button type=\\\"submit\\\">Save</button>\\n    </form>\\n  );\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"subtitle='Remix'\",\n    \"subtitle\": \"'Remix'\"\n  }), \"// This is serverside code\\nexport const loader = ({ params }) => {\\n  let bookmark = bookmarkService.get(params.bookmarkId);\\n  return { bookmark };\\n};\\n\\nexport const action = async ({ request }) => {\\n  let formData = await request.formData();\\n  let result = await bookmarkService.save(formData);\\n  // Navigate to the display/details view of the saved item\\n  return redirect(`/bookmarks/${result.id}`);\\n};\\n\\nexport default function BookmarkForm() {\\n  let { bookmark } = useLoaderData();\\n\\n  return (\\n    <form method=\\\"post\\\">\\n      <label>\\n        Title\\n        <input name=\\\"title\\\" defaultValue={bookmark.title} />\\n      </label>\\n      <label>\\n        URL\\n        <input name=\\\"url\\\" defaultValue={bookmark.url} />\\n      </label>\\n      <label>\\n        Description\\n        <textarea\\n          name=\\\"description\\\"\\n          defaultValue={bookmark.description}\\n        />\\n      </label>\\n      <button type=\\\"submit\\\">Save</button>\\n    </form>\\n  );\\n}\\n\")))), mdx(\"hr\", null), mdx(\"h2\", null, \"Auto Revalidating Loaders\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Anytime you invoke an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"action\"), \", Remix will automatically refetch any loaders.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Example: MasterDetail layout\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"List view on the left and a Details Pane/Form on the right\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"List view will automatically refresh when you add a new item.\")))), mdx(\"hr\", null), mdx(\"h2\", null, \"SSR w/ Hydration & Code Splitting\"), mdx(\"div\", {\n    style: {\n      padding: \"10vw\"\n    }\n  }, mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Has become table stakes for a Metaframeworks (like Next.js)\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"REALLY hard to DIY\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Compared to Next.js, Remix's nested routing yields granular/smaller bundles.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Remix\\u2019s push to embrace progressive enhancement means that the app can work IMMEDIATELY, even before the hydration has completed.\"))), mdx(\"hr\", null), mdx(\"h2\", null, \"Thinking in Remix\"), mdx(\"h4\", null, \"An \\\"Insta-Search\\\" page - Shows results as you type in a textbox.\"), mdx(\"div\", {\n    style: {\n      padding: \"20px\",\n      fontSize: \"22px\"\n    }\n  }, mdx(\"table\", null, mdx(\"thead\", null, mdx(\"tr\", null, mdx(\"th\", null), mdx(\"th\", null, \"Tracking Input Text\"), mdx(\"th\", null, \"Fetching Search Results\"))), mdx(\"tbody\", null, mdx(\"tr\", null, mdx(\"td\", null, mdx(\"b\", null, \"Classic React\")), mdx(\"td\", null, \"Component state - \", mdx(\"code\", null, \"useState\")), mdx(\"td\", null, mdx(\"div\", null, \"Fetch inside a \", mdx(\"code\", null, \"useEffect\"), \" that fires anytime the component state changes.\", mdx(\"br\", null), \" Watch out for race conditions though! Debounce?\"), mdx(\"p\", null, \"Or maybe you're using redux and you do the whole Redux ceremony \", mdx(\"br\", null), \" (actions, action  creators, reducers, thunks etc\\u2026)\"))), mdx(\"tr\", null, mdx(\"td\", null, mdx(\"b\", null, \"Remix\")), mdx(\"td\", null, \"Url state (querystring)\"), mdx(\"td\", null, \"Use the `loader` to fetch the results based on a query string parameter. \", mdx(\"br\", null), \"Remix will automatically handle race conditions (if the previous request \", mdx(\"br\", null), \"is cancelled because another character was typed).\"))))), mdx(\"hr\", null), mdx(\"h1\", null, \"The End\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"matchPath":"/*","isCreatedByStatefulCreatePages":false,"id":"2350c446-1a31-51c0-ba75-976f78308e86","slug":"","title":"Back to the Future"}}}